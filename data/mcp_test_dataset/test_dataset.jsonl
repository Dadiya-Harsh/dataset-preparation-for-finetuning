{"prompt": "### Instruction:\nImplement Python code for a file named 'sync_postgressql_server.py' from the 'mcp-server-suite' repository\n\n### Response:", "response": "import os\n\nimport psycopg2\nfrom dotenv import load_dotenv\nfrom mcp.server.fastmcp import FastMCP\nfrom psycopg2.extras import RealDictCursor\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Initialize FastMCP server\nmcp = FastMCP(\n    name=\"postgres_server\",\n    port=8001,\n    host=\"localhost\",\n    description=\"Access PostgresSQL databases by name and perform SQL operations\"\n)\n\n# Database connection pool\ndb_connections = {}\n\n@mcp.resource(name=\"postgres_server\", description=\"Provides access to PostgresSQL database in localhost.\", uri=os.getenv(\"DATABASE_URI\"))\ndef postgres_server():\n    \"\"\"\n    This resource establishes a connection to the specified PostgresSQL database.\n\n    Returns:\n        dict: Connection status information\n    \"\"\"\n    return {\"status\": \"ready\", \"message\": \"PostgresSQL connection resource is ready\"}\n\n@mcp.prompt(\n    name=\"postgres_query_prompt\",\n    description=\"Prompt for executing a SQL query on the PostgresSQL database.\"\n)\ndef postgres_query_prompt(db_name, query=None):\n    \"\"\"\n    Provides guidance and context for executing SQL queries.\n\n    Args:\n        db_name: The name of the database to query        : Optional query to execute\n\n    Returns:\n        list: A list of chat messages for the AI to consider\n        :param db_name:\n        :param query:\n    \"\"\"\n    # If query is provided, include it in the prompt\n    query_context = f\"\\nQuery to execute: {query}\" if query else \"\"\n\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": f\"\"\"I need to work with the PostgresSQL database named '{db_name}'.{query_context}\n\nPlease help me with the following:\n\n1. Connect to the database '{db_name}' using the connect_database tool\n2. If I provided a query, execute it using the execute_query tool\n3. If I didn't provide a query, help me explore the database by listing tables\n4. Format the results in a clear, readable way\n5. Provide brief explanations of what the data represents (if applicable)\n6. Suggest possible follow-up queries based on the schema or results\n\nRemember to use parameterized queries for any values that come from user input to prevent SQL injection.\n\"\"\"\n        }\n    ]\n\n@mcp.prompt(\n    name=\"analyze_table_prompt\",\n    description=\"Prompt for analyzing the structure and content of a database table.\"\n)\ndef analyze_table_prompt(db_name, table_name):\n    \"\"\"\n    Provides a prompt for analyzing a specific database table.\n\n    Args:\n        db_name: The name of the database\n        table_name: The name of the table to analyze\n\n    Returns:\n        list: A list of chat messages for the AI to consider\n    \"\"\"\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": f\"\"\"I need to analyze the table '{table_name}' in the PostgresSQL database '{db_name}'.\n\nPlease help me with the following:\n\n1. Connect to the database '{db_name}' using the connect_database tool\n2. Describe the structure of the '{table_name}' table using the describe_table tool\n3. Get a sample of the data (first 5-10 rows) using execute_query\n4. Analyze the table structure and provide insights on:\n   - Primary keys and relationships\n   - Data types and constraints\n   - Potential indexing opportunities\n   - Any anomalies in the schema design\n5. Summarize what this table appears to represent in the database\n6. Suggest some useful queries I might want to run on this table\n\nFormat the results in a clear, readable way with appropriate markdown formatting.\n\"\"\"\n        }\n    ]\n\n@mcp.tool(name=\"connect_database\", description=\"Connect to a specific PostgresSQL database.\")\ndef connect_database(db_name):\n    \"\"\"\n    Connects to a specific PostgresSQL database.\n\n    Args:\n        db_name (str): Name of the database to connect to\n\n    Returns:\n        dict: Connection status information\n    \"\"\"\n    if not db_name:\n        return {\"error\": \"Database name is required\"}\n\n    try:\n        # Get connection string from environment variables\n        base_uri = os.getenv(\"DATABASE_URI\")\n        if not base_uri:\n            return {\"error\": \"DATABASE_URI environment variable not set\"}\n\n        # Create a connection to the specified database\n        connection = psycopg2.connect(f\"{base_uri}/{db_name}\")\n\n        # Store the connection in our pool\n        db_connections[db_name] = connection\n\n        return {\"status\": \"success\", \"message\": f\"Connected to database '{db_name}'\"}\n\n    except Exception as e:\n        return {\"error\": str(e)}\n\n@mcp.tool(name=\"execute_query\", description=\"Executes SQL queries on the connected PostgresSQL database.\")\ndef execute_query(db_name, query, params=None):\n    \"\"\"\n    Executes SQL queries on the specified database.\n\n    Args:\n        db_name (str): Name of the database to query         (str): SQL query to execute\n        params (list, optional): Parameters for the query\n\n    Returns:\n        dict: Query results or error information\n        :param db_name:\n        :param params:\n        :param query:\n    \"\"\"\n    if not db_name:\n        return {\"error\": \"Database name is required\"}\n\n    if not query:\n        return {\"error\": \"Query is required\"}\n\n    if db_name not in db_connections:\n        # Try to connect if not already connected\n        connection_result = connect_database(db_name)\n        if \"error\" in connection_result:\n            return connection_result\n\n    connection = db_connections[db_name]\n\n    try:\n        with connection.cursor(cursor_factory=RealDictCursor) as cursor:\n            cursor.execute(query, params or [])\n\n            # For SELECT queries, return the results\n            if query.strip().upper().startswith(\"SELECT\"):\n                results = cursor.fetchall()\n                # Convert results to a list of dictionaries\n                return {\"results\": [dict(row) for row in results]}\n\n            # For other queries (INSERT, UPDATE, DELETE), commit and return row count\n            else:\n                connection.commit()\n                return {\"status\": \"success\", \"rows_affected\": cursor.rowcount}\n\n    except Exception as e:\n        connection.rollback()  # Rollback in case of error\n        return {\"error\": str(e)}\n\n@mcp.tool(name=\"list_tables\", description=\"Lists all tables in the specified database.\")\ndef list_tables(db_name):\n    \"\"\"\n    Lists all tables in the specified database.\n\n    Args:\n        db_name (str): Name of the database\n\n    Returns:\n        dict: List of tables or error information\n    \"\"\"\n    if not db_name:\n        return {\"error\": \"Database name is required\"}\n\n    query = \"\"\"\n    SELECT table_name \n    FROM information_schema.tables \n    WHERE table_schema = 'public'\n    ORDER BY table_name;\n    \"\"\"\n\n    return execute_query(db_name, query)\n\n@mcp.tool(name=\"describe_table\", description=\"Describes the structure of a specific table.\")\ndef describe_table(db_name, table_name):\n    \"\"\"\n    Describes the structure of a specific table.\n\n    Args:\n        db_name (str): Name of the database\n        table_name (str): Name of the table to describe\n\n    Returns:\n        dict: Table structure information or error\n    \"\"\"\n    if not db_name or not table_name:\n        return {\"error\": \"Database name and table name are required\"}\n\n    query = \"\"\"\n    SELECT \n        column_name, \n        data_type, \n        is_nullable,\n        column_default\n    FROM \n        information_schema.columns\n    WHERE \n        table_schema = 'public' AND \n        table_name = %s\n    ORDER BY \n        ordinal_position;\n    \"\"\"\n\n    return execute_query(db_name, query, [table_name])\n\n@mcp.tool(name=\"close_connection\", description=\"Closes the connection to the specified database.\")\ndef close_connection(db_name):\n    \"\"\"\n    Closes the connection to the specified database.\n\n    Args:\n        db_name (str): Name of the database connection to close\n\n    Returns:\n        dict: Operation status\n    \"\"\"\n    if not db_name:\n        return {\"error\": \"Database name is required\"}\n\n    if db_name not in db_connections:\n        return {\"error\": f\"No active connection to database '{db_name}'\"}\n\n    try:\n        db_connections[db_name].close()\n        del db_connections[db_name]\n        return {\"status\": \"success\", \"message\": f\"Connection to '{db_name}' closed\"}\n\n    except Exception as e:\n        return {\"error\": str(e)}\n\nif __name__ == \"__main__\":\n    print(f\"Starting MCP PostgresSQL server on http://localhost:5000\")\n    mcp.run(transport=\"sse\")", "metadata": {"source": "github", "repo": "Dadiya-Harsh/mcp-server-suite", "path": "database/postgresql/sync_postgressql_server.py", "language": "Python", "stars": 1}}
{"prompt": "### Instruction:\nImplement Python code for a file named 'web_search_stdio.py' from the 'mcp-server-suite' repository\n\n### Response:", "response": "from mcp.server.fastmcp import FastMCP\nfrom tavily import TavilyClient\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nmcp = FastMCP(name = \"Web Search\", host = \"localhost\", port = 8000)\n\n\n@mcp.tool()\nasync def web_search(query: str) -> dict:\n    \"\"\"Perform a web search using the Tavily API.\n\n    Args:\n        query: The search query string.\n\n    Returns:\n        A list of URLs from the search results.\n    \"\"\"\n    # Simulate a web search using Tavily API\n    tavily_client = TavilyClient(api_key=os.getenv(\"TAVILY_API_KEY\"))\n\n    response = tavily_client.search(query)\n    for result in response['results']:\n        print(result['title'])\n        print(result['content'])\n\n    return response\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"stdio\")\n", "metadata": {"source": "github", "repo": "Dadiya-Harsh/mcp-server-suite", "path": "web search/web_search_stdio.py", "language": "Python", "stars": 1}}
{"prompt": "### Instruction:\nImplement Python code for a file named 'web_serach_sse.py' from the 'mcp-server-suite' repository\n\n### Response:", "response": "from mcp.server.fastmcp import FastMCP, Context\nfrom mcp.types import TextContent\nfrom tavily import TavilyClient\nimport os\nfrom dotenv import load_dotenv\nimport json\n\nload_dotenv()\n\nmcp = FastMCP(\n    name=\"web_search_server\",\n    host=\"localhost\",\n    port=8000,\n    log_level=\"INFO\",\n)\n\n@mcp.tool(\n    name=\"web_search\",\n    description=\"Perform a web search using the Tavily API.\"\n)\nasync def web_search(query: str, ctx: Context) -> list[TextContent]:\n    \"\"\"\n    Perform a web search using the Tavily API.\n\n    Args:\n        query: The search query string.\n        ctx: Context for logging and progress reporting.\n\n    Returns:\n        List[TextContent]: JSON-encoded search results.\n    \"\"\"\n    await ctx.info(f\"Performing web search for query: {query}\")\n    try:\n        tavily_client = TavilyClient(api_key=os.getenv(\"TAVILY_API_KEY\"))\n        await ctx.report_progress(50, 100)\n        response = tavily_client.search(query)\n        await ctx.report_progress(100, 100)\n\n        # Format results as JSON\n        results = [\n            {\n                \"title\": result[\"title\"],\n                \"url\": result[\"url\"],\n                \"content\": result[\"content\"]\n            } for result in response[\"results\"]\n        ]\n\n        return [TextContent(\n            type=\"text\",\n            text=json.dumps({\n                \"status\": \"success\",\n                \"query\": query,\n                \"results\": results\n            })\n        )]\n    except Exception as e:\n        await ctx.error(f\"Error performing web search: {str(e)}\")\n        return [TextContent(\n            type=\"text\",\n            text=json.dumps({\n                \"status\": \"error\",\n                \"message\": str(e)\n            })\n        )]\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"sse\")", "metadata": {"source": "github", "repo": "Dadiya-Harsh/mcp-server-suite", "path": "web search/web_serach_sse.py", "language": "Python", "stars": 1}}
